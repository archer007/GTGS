var DEBUG = 0; // Global debug variable
var google_spreadsheet_id = "";
var notification_address = "";

/* Thhe following var can't go over a certain number defined by Google. Unless you're dealing 
// with over 100 emails/minute, leave it at 100. Scaling may become an issue at large traffic sizes.
*/
var inbox_search_depth = 100; 
var label_sentinel_value = "Ticket Created";
var label_sentinel_object;
var spreadsheet = SpreadsheetApp.openById(google_spreadsheet_id);
var active_sheet = spreadsheet.setActiveSheet(spreadsheet.getSheets()[0]); // Select the first sheet as the active sheet

function readMail() {
  // /*
  // Loop through all or a certain amount of email threads in the Gmail inbox. This loops through threads
  // */
  var threads = GmailApp.getInboxThreads(0, inbox_search_depth);
  for (var i = 0; i < threads.length; i++) {
    var add_thread_to_spreadsheet = true; // Assume we are going to add every thread we come across to the spreadsheet
    
    // DEBUG CODE ***** //
    if (DEBUG == 1) {
      Logger.log(threads[i].getFirstMessageSubject());
    
      if (threads[i].isUnread) {
        Logger.log("THREAD " + i + " IS MARKED UNREAD!");
        //threads[i].markRead()
      }
    }
    // END DEBUG CODE ***** //
    
    var label_match = false;
    // Now read the thread's labels, and see if it matches the label sentinel value, and is therefore already in
    // the target spreadsheet. I really don't like this section of code, it needs cleanup and testing. There is
    // definitely a cleaner way to implement the loops than this...
    threadlabels = threads[i].getLabels();
    for(var label in threadlabels) {
      if(label == label_sentinel_value || label_match == true ){ // This is annoying. Check to see if the label matches the sentinel value and should therefore NOT be added AND check to see if the sentinel label has been seen before.
        add_thread_to_spreadsheet = false;
        
        if(label == label_sentinel_value) {
          label_match = true;
        }
        
      }
      else {
        add_thread_to_spreadsheet = false;
      }
    }
    
    // Okay, so if the sentinel label WAS found, do NOT add the 1st Gmail message in the thread into the 
    // spreadsheet
    //if (add_thread_to_spreadsheet = true) {
      
      // DEBUG CODE ********* //
      if (DEBUG == 1) {
        Logger.log("DEBUG: Add thread to spreadsheet? " + add_thread_to_spreadsheet);
      }
      // END DEBUG CODE ***** //
      
    //}
    
    var messages = GmailApp.getMessagesForThread(threads[i]);
    
    // /*
    // Now loop through all messages in a thread. This is too granular for some thread-based 
    // operations, and is also horribly unoptimized.
    // */
    for (var x = 0 ; x < messages.length; x++) {
      
      if (DEBUG == 1 && messages[x].isUnread) {
        Logger.log("subject: " + messages[x].getSubject());
      }
      
      if (add_thread_to_spreadsheet == true && x == 0) {
        
        if (DEBUG == 1){
        Logger.log("Issue BODY text: " + messages[x].getBody());
        }
        
        // Add the message to the spreadsheet!
        // .replace(/<(?:.|\n)*?>/gm, '') Replace all HTML tags
        // .replace(/(\r\n|\n|\r)/gm," ") Replace all newlines with spaces
        active_sheet.appendRow([messages[x].getFrom(), messages[x].getDate(), 
                                messages[x].getBody().replace(/<(?:.|\n)*?>/gm, '').replace(/(\r\n|\n|\r)/gm," ")]);
        
        // Now mark the thread as added
        threadlabels2 = threads[i].getLabels();
        for(var label2 in threadlabels2) {
          if (label2.getName != label_sentinel_value) {
            //threads[i].addLabel(label_sentinel_object);
          }
        }
        
        //threads[i].addLabel(label_sentinel_object)
      }
      
    }
  }
}
